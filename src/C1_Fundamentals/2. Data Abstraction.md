- [1.2 数据抽象](#12-数据抽象)
  - [1.2.1 使用抽象数据类型](#121-使用抽象数据类型)
    - [1.2.1.1 抽象数据类型的API](#1211-抽象数据类型的api)
    - [1.2.1.4 对象](#1214-对象)
    - [1.2.1.5 创建对象](#1215-创建对象)
    - [1.2.1.6 调用实例方法](#1216-调用实例方法)
    - [1.2.1.7 使用对象](#1217-使用对象)
    - [1.2.1.8 赋值语句](#1218-赋值语句)
    - [1.2.1.9 将对象作为参数](#1219-将对象作为参数)
    - [1.2.1.10 将对象作为返回值](#12110-将对象作为返回值)
    - [1.2.1.11 数组也是对象](#12111-数组也是对象)
  - [1.2.2 抽象数据类型举例](#122-抽象数据类型举例)
    - [1.2.2.1 几何对象](#1221-几何对象)
    - [1.2.2.2 信息处理](#1222-信息处理)
    - [1.2.2.3 字符串](#1223-字符串)
    - [1.2.2.4 再谈输入输出](#1224-再谈输入输出)
  - [1.2.3 抽象数据类型的实现](#123-抽象数据类型的实现)
    - [1.2.3.1 实例变量](#1231-实例变量)
    - [1.2.3.2 构造函数](#1232构造函数)
    - [1.2.3.3 实例方法](#1233-实例方法)
    - [1.2.3.5 API、用例和实现](#1235api、用例和实现)
  - [1.2.4 更多抽象数据类型的实现](#124-更多抽象数据类型的实现)
    - [1.2.4.1 日期](#1241-日期)
    - [1.2.4.3 累加器](#1243-累加器)
    - [1.2.4.4 可视化的累加器](#1244-可视化的累加器)
  - [1.2.5 数据类型的设计](#125-数据类型的设计)
    - [1.2.5.1 封装](#1251-封装)
    - [1.2.5.2 设计 API](#1252-设计-api)



# 1.2 数据抽象

> Java 编程的基础主要是使用 `class` 关键字构造被称为**引用类型**的数据类型。这种风格称为**面向对象编程**，因为它的核心概念是**对象**，即保留了某个数据类型的值的实体。
>
> **抽象数据类型**（ADT）是一种能够对使用者隐藏数据表示的数据类型。抽象数据类型将数据和函数的实现关联，并将数据的表示方式隐藏起来。
>
> 在使用抽象数据类型时，我们集中于 API 描述的操作上而不会去关心数据的表示；在实现抽象数据类型时，我们集中于数据本身并实现对该数据的各种操作。

抽象数据类型之所以重要是因为它们在程序设计上支持封装，可以通过它们：

* 以适用于各种用途的 API 形式准确的解决问题
* 用 API 的实现描述算法和数据结构

## 1.2.1 使用抽象数据类型

> 要是用一种数据类型不一定非得知道它是如何实现的。

首先来编写一个使用 `Counter（计数器）` 的简单数据类型的程序。它的值是一个名称和一个非负整数，操作有创建对象并初始化为 0、当前值加 1 和获取当前值。

### 1.2.1.1 抽象数据类型的API

> 使用应用程序编程接口（API）来说明抽象数据类型的行为。它将列出所有**构造函数**和**实例方法**（即操作）并简要描述它们的作用。

数据类型定义的基础是一组值的集合，但 API 只能表达出对它们的操作，而非它们的意义。因此抽象数据类型的定义和静态方法库有许多相同点：

* 两者的实现均为 Java 类
* 实例方法可能接受 0 个或多个指定类型的参数，由括号表示并由逗号分隔
* 它们可能会返回一个指定类型的值，也可能不会（用 `void` 表示）

当然它们也有三个显著的不同：

* API 中可能会出现若干个名称和类名相同且没有返回值的函数，这些特殊的函数被称为**构造函数**
* 实例方法不需要 `static` 关键字，它们不是静态方法——它们的目的就是操作该数据类型中的值


###### 计数器的 API

```Java
public class Counter {
            Counter(String id); // 创建一个名为 id 的计数器
    void    increment();        // 将计数器的值加 1
    int     tally();            // 该对象创建之后计数器加 1 的次数
    String  toString();         // 对象的字符串表示
}
```

### 1.2.1.4 对象

可以声明一个变量 `heads` 并将它通过此代码和 `Counter` 类型的数据关联起来：
`Counter heads;`

> 所有对象都有三大重要特性：状态、标识和行为。

对象的**状态**即数据类型中的值。对象的**标识**能够将一个对象区别于另一个对象。可以认为对象的标识就是它在内存中的位置。对象的**行为**就是数据类型的操作。

**引用**是访问对象的一种方式。Java 使用术语**引用类型**来表明其和原始数据类型的区别。不同 Java 实现中引用的实现细节也不相同，但可以认为引用就是内存地址。

### 1.2.1.5 创建对象

> 要创建（或**实例化**）一个对象，用关键字 `new` 并紧跟类名以及 `()` （或在括号中制定一系列的参数，如果构造函数需要的话）来触发它的构造函数。

构造函数没有返回值，因为它总是返回它的数据类型对象的引用。每当用例调用了 `new()`，系统都会：

1. 为新对象分配内存空间
2. 调用构造函数初始化对象中的值
3. 返回该对象的一个引用

和原始数据类型不同，引用类型变量关联的是指向对象的引用而并非数据类型的值本身。

```Java
// 以下代码创建了两个不同的 Counter 对象
Counter heads = new Counter("heads");
Counter tails = new Counter("tails");
```

### 1.2.1.6 调用实例方法

> 调用一个实例方法的方式是先写出对象的变量名，紧接着是一个句点，然后是实例方法的名称。

实例方法可能会改变数据类型中的值，也可能只是访问数据类型中的值。实例方法每次触发都与一个对象相关。

```Java
Counter heads = new Counter("heads");
heads.increment();      // 触发一个实例方法并改变对象的值
heads.tally();          // 触发一个实例方法并访问对象的值
StdOut.println(heads);  // 触发 heads.toString()
```

静态方法调用的开头是类名 `Math.sqrt(2.0)`（按习惯为大写），而实例方法调用的开头总是对象名 `heads.increment()`（按习惯为小写）。

### 1.2.1.7 使用对象

要开发某种给定数据类型的用例，需要：

* 声明该类型的变量以引用该对象
* 使用关键字 `new` 触发创建该类型的对象的构造函数
* 使用变量名在语句或表达式中调用实例方法

### 1.2.1.8 赋值语句

> 引用类型的赋值语句会创建该引用的一个副本：赋值语句不会创建新的对象，而是创建一个指向已存在对象的引用。这种情况被称为**起别名**：两个变量同时指向一个对象。

### 1.2.1.9 将对象作为参数

> 当使用引用类型作为参数时我们创建的都是别名。

### 1.2.1.10 将对象作为返回值

> C1_2_DataAbstraction `FlipsMax`

### 1.2.1.11 数组也是对象

### 1.2.1.12 对象的数组

创建一个数组需要以下两个步骤：

* 使用方括号语法调用数组的构造函数创建数组
* 对每个数组元素调用它的构造函数创建相应的对象

> C1_2DataAbstraction `Rolls`

## 1.2.2 抽象数据类型举例

### 1.2.2.1 几何对象

下面为三种常见的几何对象定义了相应的抽象数据类型：`Point2D`、`Interval1D`、`Interval2D（平面上的二维间隔，即和数轴对其的长方形）`。

```Java
// 平面上的点的 API
public class Point2D {
            Point2D(double x, double y);    // 创建一个点
    double  x();                            // x 坐标
    double  y();                            // y 坐标
    double  r();                            // 极径（极坐标）
    double  theta();                        // 极角（极坐标）
    double  distTo(Point2D that);           // 从该点到 that 的欧几里得距离
    void    draw();                         // 用 StdDraw 绘出该点
}

// 线段的 API
public class Interval1D {
            Interval1D(double lo, double hi);   // 创建一个线段
    double  length();                           // 线段长度
    boolean contains(double x);                 // x 是否在线段中
    boolean intersect(Interval1D that);         // 该线段是否与线段 that 相交
    void    draw();                             // 用 StdDraw 绘出该线段
}

// 平面上的二维区域的 API
public class Interval2D {
            Interval2D(Interval1D x, Interval1D);   // 创建一个二维区域
    double  area();                                 // 二维区域的面积
    boolean contains(Point2D p);                    // p 是否在二维区域中
    boolean intersect(Interval2D that);             // 该区域是否和二维区域 that 相交
    void    draw();                                 // 用 StdDraw 绘出该二维区域
}
```

`Interval2D` 的测试用例：`Interval2DTest`

### 1.2.2.2 信息处理

> 抽象数据类型是组织信息的一种自然方式。主要思想是定义和真实世界中的物体相对应的对象。

```java
// 商业应用程序中的示例 API （日期和交易）
/**
 * 一个日期就是一个日、月和年的集合，一笔交易就是一个客户、日期和金额的集合。为了简化用例代码，每个类型都
 * 提供了两个构造函数，一个接受适当类型的数据，另一个则能够解析字符串中的数据。
 * 这种组织数据方式的好处之一是将一个对象和它相关的数据变成一个整体，这些数据类型的重点在于封装数据，同时
 * 它们也可以确保用例的代码不依赖于数据的表示方法。
 */
public class Date implements Comparable<Date> {
            Date(int month, int day, int year);    // 创建一个日期
            Date(String date);                     // 创建一个日期（解析字符串的构造函数）
    int     month();                               // 月
    int     day();                                 // 日
    int     year();                                // 年
    String  toString();                            // 对象的字符串表示
    boolean equals(Objectg that);                  // 该日期和 that 是否相同
    int     compareTo(Date that);                  // 将该日期和 that 比较
    int     hashCode();                            // 散列值
}

public class Transaction implements Comparable<Transaction> {
            Transaction(String who,  Date when, double amount);
            Transaction(String transaction);      // 创建一笔交易（解析字符串的构造函数）
    String  who();                                // 客户名
    Date    when();                               // 交易日期
    double  amount();                             // 交易金额
    String  toString();                           // 对象的字符串表示
    boolean equals(Object that);                  // 该笔交易和 that 是否相同
    int     compareTo(Transaction that);          // 将该笔交易和 that 比较
    int     hashCode();                           // 散列值
}
```

**每当遇到逻辑上相关的不同类型的数据时**，都应该像这些例子这样定义一个抽象数据类型。这么做能帮助我们组织数据并在一般应用程序中极大的简化使用者的代码。

### 1.2.2.3 字符串

`String` 值和字符数组类似，但两者是不同的。数组能够通过 Java 语言的内置语法访问每个字符，`String` 则为索引访问、字符串长度以及其他许多操作准备了实例方法。Java 还为 `String` 的初始化和连接提供了特比的支持：可以直接使用字符串字面量而非构造函数来创建并初始化一个字符串，还可以直接使用 `+` 运算符代替 `concat()` 方法。

```java
public class String {
             String();                          // 创建一个空字符串
    int      length();                          // 字符串长度
    int      charAt(int i);                     // 第 i 个字符
    int      indexOf(String p);                 // p 第一次出现的位置（没有则返回 -1）
    int      indexOf(String p, int i);          // p 在 i 个字符后第一次出现的位置（如果没有则返回 -1）
    String   concat(String t);                  // 将 t 插入到该字符串末尾
    String   substring(int i, int j);           // 该字符串的子字符串（第 i 个字符到第 j - 1 个字符）
    String[] split(String delim);               // 使用 delim 分隔符切分字符串
    int      compareTo(String t);               // 比较字符串
    boolean  equals(String t);                  // 该字符串的值和 t 是否相同
    int      hashCode();                        // 散列值
}
```

**典型的字符串处理代码**

```java
// 判断字符串是否是一条回文
public static boolean isPalindrome(String s) {
    int N = s.length();
    for (int i = 0; i < N / 2; i++)
        if (s.charAt(i) != s.charAt(N - i - 1)
            return false;
    return true;
}

// 从一个命令行参数中提取文件和扩展名
String s = args[0];
int dot = s.indexOf(".");
String base = s.substring(0, dot);
String extension = s.substring(dot + 1, s.length());

// 打印出标准输入中所有含有通过命令行指定的字符串的行
String query = args[0];
while (!StdIn.isEmpty()) {
    String s = StdIn.readLine();
    if (s.contains(query)) StdOut.println(s);
}

// 以空白字符为分隔符从 StdIn 中创建一个字符串数组
String input = StdIn.readAll();
String[] words = input.split("\\s+");

// 检查一个字符串数组中的元素是否已按照字母表顺序排列
public boolean isSorted(String[] a) {
    for (int i = 1; i < a.length; i++) {
        if (a[i - 1].compareTo(a[i] > 0)
            return false;
    }
    return true;
}
```

### 1.2.2.4 再谈输入输出

之前的 `StdIn、StdOut、StdDraw` 标准库的一个缺点是对于任意程序只能接收一个输入文件、向一个文件输出或是产生一副图像。有了面向对象编程就可以定义类似的机制在一个程序中同时处理**多个**输入流、输出流和图像。算法4 的标准库定义了数据类型 `In、Out、Draw` ，它们的 API 如下所示。

```java
/*
 * 当使用一个 String 类型的参数调用它们的构造函数时，In 和 Out 会首先尝试在当前目录下查找指定的文件。
 * 如果找不到它就会假设该参数是一个网站的名称并尝试连接到那个网站（如果该网站不存在，它会抛出一个运行时
 * 异常）。无论哪种情况，指定的文件或网站都会成为被创建的输入或输出流对象的来源或目标，所有 read*() 和
 * print*() 方法都会指向那个文件或网站（如果使用的是无参的构造函数，对象将会使用标准的输入输出流）。这
 * 种机制使得单个程序能够处理多个文件和图像。
 */
public class In {
            In();                  // 从标准输入创建输入流
            In(String name);       // 从文件或网站创建输入流
    boolean isEmpty();             // 如果输入流为空则返回 true，否则返回 false
    int     readInt();             // 读取一个 int 类型的值
    double  readDouble();          // 读取一个 double 类型的值
    ... 
    void    close();               // 关闭输入流
}

public class Out {
            Out();                 // 从标准输出创建输出流
            Out(String name);      // 从文件创建输出流
    void    print(String s);       // 将 s 添加到输出流中
    void    println(String s);     // 将 s 和一个换行符添加到输出流中
    void    println();             // 将一个换行符添加到输出流中
    void    printf(String f, ...); // 格式化并打印到输出流中
    void    close();               // 关闭输出流
}

public class Draw {
            Draw();
    void    line(double x0, double y0, double x1, double y1);
    void    point(double x, double y);
}
```

## 1.2.3 抽象数据类型的实现

和静态方法库一样，我们需要使用 Java 的 `class` 实现抽象数据类型并将所有代码放入一个和类名相同并带有 .java 扩展名的文件中。

计数器类的实现： `Counter`


### 1.2.3.1 实例变量

要定义数据类型的值（即每个对象的状态），需要声明**实例变量**，声明的方式和局部变量差不多。每个实例变量对应着无数值（数据类型的每个实例对象都会有一个实例变量）。每个实例变量的声明都需要一个可见性修饰符，这里使用 `private` 来保证向使用者隐藏抽象数据类型中的数据表示。如果该值在初始化之后不再被改变则使用 `final` 修饰符。


### 1.2.3.2 构造函数

每个 Java 类都至少有一个**构造函数**来创建一个对象的标识。一般来说构造函数的作用时初始化实例变量。每个构造函数都将创建一个对象并向调用者返回一个该对象的引用。构造函数的名称总是和类名相同，我们可以和重载方法一样重载这个构造函数。


### 1.2.3.3 实例方法

实例方法的所有行为都和静态方法相同，只有一点关键的不同：**实例方法可以访问并操作实例变量**。当我们调用 `heads.increment()` 时，`increment()` 方法中的代码访问的是 `heads` 中的实例变量。


### 1.2.3.5 API、用例和实现

要完全理解一个数据类型，需要它的 API、典型的用例和它的实现。我们会按照下面三步走的方式开发抽象数据类型：

* 定义一份 API：将**使用和实现分离**，以实现模块化编程。制定一份 API 的目的有两个：1. 希望用例的代码清晰而明确；2. 我们希望能实现这些操作，定义一些无法实现的操作是没有意义的。
* 用一个 Java 类实现 API 的定义：选择适当的实例变量，然后在编写构造函数和实例方法。
* 实现多个测试用例来验证前两步做出的设计决定。

比如一个[简单的计数器的抽象数据类型 API](#计数器的API)、典型的用例 `Flips` 、数据类型的实现 `Counter`



## 1.2.4 更多抽象数据类型的实现

### 1.2.4.1 日期

`Date1` 和 `Date2` 是下面定义的 Date 抽象数据类型的两种实现。简单期间省略了解析字符串的构造函数和继承的方法 `equals()、compareTo()、hashCode()`。在实现中使用数据抽象的一个关键优势是我们可以将一种实现替换为另一种实现而**无需改变用例的任何代码**。


###### 封装日期的抽象数据类型

```java
public class Date {
            Date(int month, int day, int year);   // 创建一个日期
    int     day();                                // 日
    int     month();                              // 月
    int     year();                               // 年
    String  toString();                           // 对象的字符串表示
}


// 测试用例
public static void main(String[] args) {
    int m = Integer.parseInt(args[0]);
    int d = Integer.parseInt(args[1]);
    int y = Integer.parseInt(args[2]);
    Date date = new Date(m, d, y);  
    StdOut.println(date);
}

// 使用方法
% java Date 12 31 1999
12/31/1999
```

### 1.2.4.3 累加器

下面的累加器 API 定义了一种能为用例计算一组数据的实时平均值的抽象数据类型。实现很简单：它维护一个 `int` 类型的实例变量来记录已经处理过的数据值的数量，以及一个 `double` 类型的实例变量来记录所有数据值之和，将和除以数据数量即可得到平均值。注意该实现并没有保存数据的值——它可以用于处理大规模的数据（甚至是在一个无法全部保存它们的设备上），这种性能特点很容易被忽视，所以也许应该在 API 中注明，因为一种存储所有数据值的实现可能会使调用它的应用程序用光所有的内存。

###### 能够累加数据的抽象数据类型

```java
public class Accumlator {
            Accumlator();              // 创建一个累加器
    void    addDataValue(double val);  // 添加一个新的数据值
    double  mean();                    // 所有数据值的平均值
    String  toString();                // 对象的字符串表示
}
```

数据类型的实现及其典型用例： `Accumulator`


### 1.2.4.4 可视化的累加器

下面所示的可视化累加器的实现继承了 `Accumulator` 类病展示了一种实用的副作用：它用 `StdDraw` 画出了所有数据（灰色）和实时的平均值（红色）。完成这项任务最简单的办法是添加一个构造函数来制定需要绘出的点数和它们的最大值（用于调整图像的比例）。

```java
public class VisualAccumulator {
            VisualAccumulator(int trials, double max);
    void    addDataValue(double val);     // 添加一个新的数据值
    double  mean();                       // 所有数据的平均值
    String  toString();                   // 对象的字符串表示
}
```

数据类型的实现及其典型用例：`VisualAccumulator`


## 1.2.5 数据类型的设计

> 抽象数据类型是一种向用例隐藏内部表示的数据类型。

### 1.2.5.1 封装

面向对象编程的特征之一就是使用数据类型的实现**封装**数据以简化实现和隔离用例开发。封装实现了模块化编程，它允许我们：

* 独立开发用例和实现的代码
* 切换至改进的实现而不会影响用例的代码
* 支持尚未编写的程序

一个封装的数据类型可以被任意用例使用，因此它扩展了语言本身。将大型程序分解为能够独立开发和调试的小型模块是大家提倡的编程风格，这种方式将修改代码的影响限制在局部范围。模块化编程成功的关键在于它保持了模块之间的**独立性**。算法4 坚持将 API 作为用例和实现之间唯一的依赖点——**并不需要知道一个数据类型是如何实现的才能使用它，实现数据类型时应该假设使用者除了 API 什么也不知道**。


### 1.2.5.2 设计 API

理想情况下，一份 API 应该能够清楚的说明所有可能的输入和副作用，但这个目标是不可能实现的的。我们的 API 将会是和抽象数据类型相关联的值以及一系列构造函数和实例方法的的目的和副作用的自然语言描述。API 的设计可以总结为一句话：**只为用例提供它们所需要的，仅此而已**。


### 1.2.5.3 算法与抽象数据类型

数据抽象能够为我们提供准确说明一个算法的目的以及其他程序应该如何使用该算法的框架。`C1_1` 中的白名单粒子就很自然的被实现为一个抽象数据类型的典型用例，它进行了以下操作：

* 由一组给定的值构造了一个 `SET（集合）` 对象
* 判定一个给定的值是否存在于该集合中

这些操作封装在 `StaticSETofInts` 抽象数据类型中，和用例一起。`StaticSETofInts` 是更一般也更有用的**符号表**抽象数据类型的一种特殊情况。和 `C1_1` 中的 `BinarySearch` 比起来，这里的实现所产生的用例代码更加清晰高效。比如 `StaticSETofInts` 强制要求数组在 `rank()` 方法被调用之前排序。

```java
public class StaticSETofInts {
            StaticSETofInts(int[] a);  // 根据 a[] 中的所有值创建一个集合
    boolean contains(int key);         // key 是否存在于集合中
}
```

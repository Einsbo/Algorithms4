- [1.2 数据抽象](#12-数据抽象)  
    - [1.2.1 使用抽象数据类型](#121-使用抽象数据类型)
      - [1.2.1.1 抽象数据类型的API](#1211-抽象数据类型的api)
      - [1.2.1.4 对象](#1214-对象)
      - [1.2.1.5 创建对象](#1215-创建对象)
      - [1.2.1.6 调用实例方法](#1216-调用实例方法)
      - [1.2.1.7 使用对象](#1217-使用对象)
      - [1.2.1.8 赋值语句](#1218-赋值语句)
      - [1.2.1.9 将对象作为参数](#1219-将对象作为参数)
      - [1.2.1.10 将对象作为返回值](#12110-将对象作为返回值)
      - [1.2.1.11 数组也是对象](#12111-数组也是对象)
    - [1.2.2 抽象数据类型举例](#122-抽象数据类型举例)
      - [1.2.2.1 几何对象](#1221-几何对象)

# 1.2 数据抽象
> Java 编程的基础主要是使用 `class` 关键字构造被称为**引用类型**的数据类型。这种风格称为**面向对象编程**，因为它的核心概念是**对象**，即保留了某个数据类型的值的实体。
> 
> **抽象数据类型**（ADT）是一种能够对使用者隐藏数据表示的数据类型。抽象数据类型将数据和函数的实现关联，并将数据的表示方式隐藏起来。
> 
> 在使用抽象数据类型时，我们集中于 API 描述的操作上而不会去关心数据的表示；在实现抽象数据类型时，我们集中于数据本身并实现对该数据的各种操作。

抽象数据类型之所以重要是因为它们在程序设计上支持封装，可以通过它们：
* 以适用于各种用途的 API 形式准确的解决问题
* 用 API 的实现描述算法和数据结构

## 1.2.1 使用抽象数据类型
> 要是用一种数据类型不一定非得知道它是如何实现的。

首先来编写一个使用 `Counter（计数器）` 的简单数据类型的程序。它的值是一个名称和一个非负整数，操作有创建对象并初始化为 0、当前值加 1 和获取当前值。

### 1.2.1.1 抽象数据类型的API
> 使用应用程序编程接口（API）来说明抽象数据类型的行为。它将列出所有**构造函数**和**实例方法**（即操作）并简要描述它们的作用。

数据类型定义的基础是一组值的集合，但 API 只能表达出对它们的操作，而非它们的意义。因此抽象数据类型的定义和静态方法库有许多相同点：
* 两者的实现均为 Java 类
* 实例方法可能接受 0 个或多个指定类型的参数，由括号表示并由逗号分隔
* 它们可能会返回一个指定类型的值，也可能不会（用 `void` 表示）

当然它们也有三个显著的不同：
* API 中可能会出现若干个名称和类名相同且没有返回值的函数，这些特殊的函数被称为**构造函数**
* 实例方法不需要 `static` 关键字，它们不是静态方法——它们的目的就是操作该数据类型中的值


```Java
// 计数器的 API
public class Counter {
            Counter(String id); // 创建一个名为 id 的计数器
    void    increment();        // 将计数器的值加 1
    int     tally();            // 该对象创建之后计数器加 1 的次数
    String  toString();         // 对象的字符串表示
}
```

### 1.2.1.4 对象
可以声明一个变量 `heads` 并将它通过此代码和 `Counter` 类型的数据关联起来：
`Counter heads;`

> 所有对象都有三大重要特性：状态、标识和行为。

对象的**状态**即数据类型中的值。对象的**标识**能够将一个对象区别于另一个对象。可以认为对象的标识就是它在内存中的位置。对象的**行为**就是数据类型的操作。

**引用**是访问对象的一种方式。Java 使用术语**引用类型**来表明其和原始数据类型的区别。不同 Java 实现中引用的实现细节也不相同，但可以认为引用就是内存地址。

### 1.2.1.5 创建对象
> 要创建（或**实例化**）一个对象，用关键字 `new` 并紧跟类名以及 `()` （或在括号中制定一系列的参数，如果构造函数需要的话）来触发它的构造函数。

构造函数没有返回值，因为它总是返回它的数据类型对象的引用。每当用例调用了 `new()`，系统都会：
1. 为新对象分配内存空间 
2. 调用构造函数初始化对象中的值 
3. 返回该对象的一个引用

和原始数据类型不同，引用类型变量关联的是指向对象的引用而并非数据类型的值本身。
```Java
// 以下代码创建了两个不同的 Counter 对象
Counter heads = new Counter("heads");
Counter tails = new Counter("tails");
```

### 1.2.1.6 调用实例方法
> 调用一个实例方法的方式是先写出对象的变量名，紧接着是一个句点，然后是实例方法的名称。

实例方法可能会改变数据类型中的值，也可能只是访问数据类型中的值。实例方法每次触发都与一个对象相关。
```Java
Counter heads = new Counter("heads");
heads.increment();      // 触发一个实例方法并改变对象的值
heads.tally();          // 触发一个实例方法并访问对象的值
StdOut.println(heads);  // 触发 heads.toString()
```
静态方法调用的开头是类名 `Math.sqrt(2.0)`（按习惯为大写），而实例方法调用的开头总是对象名 `heads.increment()`（按习惯为小写）。

### 1.2.1.7 使用对象
要开发某种给定数据类型的用例，需要：
* 声明该类型的变量以引用该对象
* 使用关键字 `new` 触发创建该类型的对象的构造函数
* 使用变量名在语句或表达式中调用实例方法

### 1.2.1.8 赋值语句
> 引用类型的赋值语句会创建该引用的一个副本：赋值语句不会创建新的对象，而是创建一个指向已存在对象的引用。这种情况被称为**起别名**：两个变量同时指向一个对象。

### 1.2.1.9 将对象作为参数
> 当使用引用类型作为参数时我们创建的都是别名。

### 1.2.1.10 将对象作为返回值
> C1_2_DataAbstraction `FlipsMax`

### 1.2.1.11 数组也是对象

### 1.2.1.12 对象的数组
创建一个数组需要以下两个步骤：
* 使用方括号语法调用数组的构造函数创建数组
* 对每个数组元素调用它的构造函数创建相应的对象

> C1_2DataAbstraction `Rolls`

## 1.2.2 抽象数据类型举例

### 1.2.2.1 几何对象
下面为三种常见的几何对象定义了相应的抽象数据类型：`Point2D`、`Interval1D`、`Interval2D（平面上的二维间隔，即和数轴对其的长方形）`。
```Java
// 平面上的点的 API
public class Point2D {
            Point2D(double x, double y);    // 创建一个点
    double  x();                            // x 坐标
    double  y();                            // y 坐标
    double  r();                            // 极径（极坐标）
    double  theta();                        // 极角（极坐标）
    double  distTo(Point2D that);           // 从该点到 that 的欧几里得距离
    void    draw();                         // 用 StdDraw 绘出该点
}

// 线段的 API
public class Interval1D {
            Interval1D(double lo, double hi);   // 创建一个线段
    double  length();                           // 线段长度
    boolean contains(double x);                 // x 是否在线段中
    boolean intersect(Interval1D that);         // 该线段是否与线段 that 相交
    void    draw();                             // 用 StdDraw 绘出该线段
}

// 平面上的二维区域的 API
public class Interval2D {
            Interval2D(Interval1D x, Interval1D);   // 创建一个二维区域
    double  area();                                 // 二维区域的面积
    boolean contains(Point2D p);                    // p 是否在二维区域中
    boolean intersect(Interval2D that);             // 该区域是否和二维区域 that 相交
    void    draw();                                 // 用 StdDraw 绘出该二维区域
}
```

`Interval2D` 的测试用例：
- [1.3 背包、队列和栈](#背包、队列和栈)
  - [1.3.1 API](#131-api)
  - [1.3.1.1 泛型](#1311-泛型)
  - [1.3.1.2 自动装箱](#1312-自动装箱)
  - [1.3.1.3 可迭代的集合类型](#1313-可迭代的集合类型)




# 1.3 背包、队列和栈



## 1.3.1 API

> 对集合形抽象数据类型的讨论从定义它们的 API 开始，没份 API 都含有一个无参数的构造函数、一个向集合中添加单个元素的方法、一个测试集合是否为空的方法和一个返回集合大小的方法。`Stack` 和 `Queue` 都含有一个能够删除集合中特定元素的方法。

```java
// 背包
public class Bag<Item> implements Interable<Item> {
            Bag();              // 创建一个空背包
    void    add(Item item);     // 添加一个元素
    boolean isEmpty();          // 背包是否为空
    int     size();             // 背包中的元素数量
}

// 先进先出（FIFO）队列
pulbic class Queue<Item> implements Interable<Item> {
            Queue();            // 创建空队列
    void    enqueue(Item item); // 添加一个元素
    Item    dequeue();          // 删除最早添加的元素
    boolean isEmpty();          // 队列是否为空
    int     size();             // 队列中的元素数量
}

// 下压（后进先出，LIFO）栈
public class Stack<Item> implements Interable<Item> {
            Stack();            // 创建一个空栈
    void    push(Item item);    // 添加一个元素
    Item    pop();              // 删除最近添加的元素
    boolean isEmpty();          // 栈是否为空
    int     size();             // 栈中的元素数量
}
```




### 1.3.1.1 泛型

集合类抽象数据类型的一个关键特性是我们可以用它们存储任意类型的数据。Java 的**泛型（参数化类型）**可以做到这点。在每份 API 中，类名后的 `<Item>` 记号将 Item 定义为一个**类型参数**，它是一个象征性的占位符，表示的是用例可能使用的某种数据类型。可以将 `Stack<Item>` 理解为某种元素的栈，在实现 `Stack` 时，我们不知道 Item 的具体类型，但用例可以用我们的栈处理任意类型的数据，甚至是在我们的实现之后才出现的数据类型。

在创建栈时，用例会提供一种具体的数据类型，我们可以将 Item 替换为任意引用数据类型：

```java
// 可以编写下面的代码用栈处理 String 对象
Stack<String> stack = new Stack<String>();
stack.push("Test");
...
String next = stack.pop();

// 下面的代码使用队列处理 Date 对象
Queue<Date> queue = new Queue<Date>();
queue.enqueue(new Date(12, 31, 1999));
...
Date next = queue.dequeue();
```

泛型可以让我们只定义一份 API 就能够处理所有类型的数据，甚至是在未来定义的数据类型。



### 1.3.1.2 自动装箱

类型参数必须被实例化为**引用**类型，因此 Java 有一种机制来让泛型代码能够处理原始类型数据——在处理赋值语句、方法的参数和算数或逻辑表达式时，Java 会自动在引用类型和对应的原始数据类型之间进行转换，这种转换让我们可以同时使用泛型和原始数据类型：

```java
Stack<Integer> stack = new Stack<Integer>();
stack.push(17);      // 自动装箱 (int -> Integer)
int i = stack.pop(); // 自动拆箱 (Integer -> int)
```



### 1.3.1.3 可迭代的集合类型

对于许多应用场景，用例的要求只是用某种方式处理集合中的每个元素，或者叫做**迭代访问**集合中的所有元素。有了它就能够不依赖于集合类型的具体实现写出清晰简洁的代码。假设用例在 `Queue` 中维护一个交易集合：

```java
Queue<Transaction> collection = new Queue<Transaction>();

// 如果集合是可迭代的，用例用一行语句即可打印出交易的列表:
for (Transaction t : collection) { StdOut.println(t); }

/**
 * 这个语法叫 foreach 语句：可以将 for 语句看作对于集合中的每个交易 t(foreach) 执行以下代码段。这段用例代码
 * 不需要知道集合的表示或实现的任何细节，它只想逐个处理集合中的元素。
 * 支持这种迭代需要在实现中添加额外的代码，但这些工作是值得的。
 */
```



### 1.3.1.4 背包

> 背包是一种不支持从中删除元素的集合数据类型——它的目的就是帮助用例收集元素并迭代遍历所有收集到的元素。迭代的顺序不确定且与用例无关。

要理解背包的概念，可以想像一个非常喜欢收集邮票的人，他将所有的邮票都放在一个背包里，一次一个，并且时不时的在所有邮票中寻找某一张拥有某种特点的邮票。用例也可以使用栈或是队列，但使用 `Bag` 可以说明元素的处理顺序不重要。

`Stats` 程序是背包的一个典型用例。
